% \newlist{myap}{enumerate}{5}
% \newcommand{\myapi}{\arabic{myapi}.}
% \newcommand{\myapii}{\myapi\arabic{myapii}.}
% \newcommand{\myapiii}{\myapii\arabic{myapiii}.}
% \newcommand{\myapiv}{\myapiii\arabic{myapiv}.}
% \newcommand{\myapv}{\myapiv\arabic{myapv}.}

% \setlist[myap,1]{
%     label = \fontsize{13}{0} Phụ lục \myapi,
%     leftmargin=2.5cm,
%     %rightmargin=10pt
% }
% \setlist[myap,2]{
%     label = \myapii
% }
% \setlist[myap,3]{
%     label = \myapiii
% }
% \setlist[myap,4]{
%     label = \myapiv
% }
% \setlist[myap,5]{
%     label = \myapv
% }




\chapter*{PHỤ LỤC}
\addcontentsline{toc}{chapter}{PHỤ LỤC}
\addtocontents{toc}{\protect\setcounter{tocdepth}{0}}
{
\setcounter{chapter}{1}
% \titleformat{\chapter}[block]{\centering}{\textbf{\MakeUppercase\chaptername\space\thechapter.\space}}{0pt}{\textbf}{}
\renewcommand{\thesection}{\arabic{section}}
\renewcommand{\thesubsection}{\thesection.\arabic{subsection}}
\renewcommand{\thesubsubsection}{\thesubsection.\arabic{subsubsection}}
\renewcommand{\theparagraph}{\thesubsubsection.\arabic{paragraph}}
\renewcommand{\thesubparagraph}{\theparagraph.\arabic{subparagraph}}
\titleformat{\section}[block]{}{\textbf{Phụ lục \thesection. }}{0pt}{\textbf}{}
\titleformat{\subsection}[block]{}{\textbf{\thesubsection. }}{0pt}{\textbf}{}
\titleformat{\subsubsection}[block]{}{\textbf{\thesubsubsection. }}{0pt}{\textbf}{}
\titleformat{\paragraph}[block]{}{\textbf{\theparagraph. }}{0pt}{\textbf}{}
\titleformat{\subparagraph}[block]{}{\textbf{\thesubparagraph. }}{0pt}{\textbf}{}


\section{Mã chương trình}
\subsection{Bộ phân tích từ vựng}
\subsubsection{Phân tích từ tố sơ cấp}
\begin{itemize}
  \item \label{ap1:simple_token}Từ tố sơ cấp. \textbf{(lexer::token::Token)}
  \begin{lstlisting}[]
    pub struct Token {
      pub kind: TokenKind,
      pub len: u32,
    }
  \end{lstlisting}
  \item Các loại từ tố sơ cấp. \textbf{(lexer::token::TokenKind)}
  \begin{lstlisting}[]
    pub enum TokenKind {
      /* one char symbol */
      /// :
      Colon,
      /// ,
      Comma,
      /// .
      Dot,
      /// ;
      Semicolon,
      /// ?
      Question,
      /// (
      OpenParen,
      /// )
      CloseParen,
      /// {
      OpenBrace,
      /// }
      CloseBrace,
      /// [
      OpenBracket,
      /// ]
      CloseBracket,
      /// `!`
      Bang,
      /// `=`
      Eq,
      /// `>`
      Gt,
      /// `<`
      Lt,
      /// `~`
      Tilde,
      /// `+`
      Plus,
      /// `-`
      Minus,
      /// `*`
      Star,
      /// `/`
      Slash,
      /// `%`
      Percent,
      /// `^`
      Caret,
      /// `&`
      And,
      /// `|`
      Or,

      // Literal
      Literal(LiteralKind),

      // Identifier
      Ident,

      // Raw identifier
      RawIdent,

      // Comments
      LineComment {
          doc_style: Option<DocStyle>,
      },
      BlockComment {
          doc_style: Option<DocStyle>,
          terminated: bool,
      },

      Whitespace,

      // Unknown token's kind.
      Unknown,

      /// End of input.
      Eof,
    }
  \end{lstlisting}
  \item Loại từ tố chuỗi ký tự. \textbf{(lexer::token::LiteralKind)}
  \begin{lstlisting}
    pub enum LiteralKind {
      /// `"abc"`, `"ab`, `"ab\"`, `"ab\""`.
      Str {
          terminated: bool,
      },
      /// `r#"abc"#`, `r###"ab"##c"###`, `r###"ab"######`, None means invalid.
      RawStr {
          n_hashes: Option<u8>,
      },
      /// `1_000`, `0b1101`, `0o657`, `0h1af9`.
      Int {
          base: Base,
          empty_int: bool,
      },
      Float {
          base: Base,
          empty_exponent: bool,
      },
      // Although kind can be Char but it can be many symbols (error). Ex: 'abc' -> error.
      /// `'a'`, `'\''`, `'\\'`, `'abc'`, `'ab`.
      Char {
          terminated: bool,
      },
    }
  \end{lstlisting}
  \item Hàm \textit{advance\_token}. \textbf{(lexer::advance\_token)}
  \begin{lstlisting}
    pub fn advance_token(&mut self) -> Token {
      self.reset_bytes_eaten();

      let first_char = match self.eat() {
          Some(c) => c,
          None => return Token::new(TokenKind::Eof, 0),
      };

      let kind = match first_char {
          c if is_whitespace(c) => self.whitespace(),

          ':' => TokenKind::Colon,
          ',' => TokenKind::Comma,
          '.' => TokenKind::Dot,
          ';' => TokenKind::Semicolon,
          '?' => TokenKind::Question,
          '(' => TokenKind::OpenParen,
          ')' => TokenKind::CloseParen,
          '[' => TokenKind::OpenBracket,
          ']' => TokenKind::CloseBracket,
          '{' => TokenKind::OpenBrace,
          '}' => TokenKind::CloseBrace,
          '!' => TokenKind::Bang,
          '=' => TokenKind::Eq,
          '>' => TokenKind::Gt,
          '<' => TokenKind::Lt,
          '~' => TokenKind::Tilde,
          '+' => TokenKind::Plus,
          '-' => TokenKind::Minus,
          '*' => TokenKind::Star,
          '%' => TokenKind::Percent,
          '^' => TokenKind::Caret,
          '&' => TokenKind::And,
          '|' => TokenKind::Or,

          // Slash, comment or block comment.
          '/' => match self.first() {
              '/' => self.line_comment(),
              '*' => self.block_comment(),
              _ => TokenKind::Slash,
          },

          '0'..='9' => self.number(),

          // Raw identifier, Identifier, Raw double quote string
          'r' => match (self.first(), self.second()) {
              ('#', c1) if is_id_start(c1) => self.raw_identifier(),
              ('#', _) | ('"', _) => {
                  let res = self.raw_double_quote_string();
                  TokenKind::Literal(LiteralKind::RawStr { n_hashes: res.ok() })
              }
              _ => self.identifier(),
          },

          '\'' => self.single_quote_string(),
          '"' => self.double_quote_string(),

          c if is_id_start(c) => self.identifier(),

          _ => TokenKind::Unknown,
      };

      Token::new(kind, self.bytes_eaten())
    }
  \end{lstlisting}
\end{itemize}

\subsubsection{Phân tích từ tố thứ cấp}
\begin{itemize}
  \item \label{ap1:flextoken}Từ tố thứ cấp. \textbf{(ast::token::Token)}
  \begin{lstlisting}[]
    pub struct Token {
      pub kind: TokenKind,
      pub span: Span,
    }
  \end{lstlisting}
  \item Vị trí của từ tố thứ cấp.
  \item Các loại từ tố thứ cấp.
  \item Loại từ tố phép toán học.
  \item Loại từ tố ngoặc.
  \item Loại từ tố chuỗi ký tự.
  \item Loại từ tố tên.
  \item Loại từ tố chú thích tài liệu.
  \item Hàm \textit{next\_token}
\end{itemize}

\subsubsection{Phân tích cây từ tố}
\begin{itemize}
  \item \label{ap1:tokentree}Cây từ tố. \textbf{(ast::tokenstream::TokenTree)}
  \begin{lstlisting}
    pub enum TokenTree {
      /// A single token. Should never be `OpenDelim` or `CloseDelim`, because
      /// delimiters are implicitly represented by `Delimited`.
      Token(Token, Spacing),
      // A delimited sequence of token trees.
      Delimited(DelimSpan, Delimiter, TokenStream),
    }
  \end{lstlisting}
  \item Kiểu liên kết từ tố.
  \item Vị trí đóng mở ngoặc.
  \item Kiểu của ngoặc
  \item Hàm \textit{lex\_token\_trees}
\end{itemize}

\subsection{Bộ phân tích cú pháp}
\subsubsection{Hàm \textit{parse\_stmt}}
\label{ap1:stmt}
\begin{lstlisting}
pub fn parse_stmt(&mut self) -> PResult<Box<Stmt>> {
  if self.token.is_keyword(Keyword::Set) {
      self.parse_stmt_var_decl()
  } else if self.token.is_keyword(Keyword::When) {
      self.parse_stmt_if()
  } else if self.token.kind == TokenKind::OpenDelim(Delimiter::Brace) {
      self.parse_stmt_block()
  } else if self.token.is_keyword(Keyword::During) {
      self.parse_stmt_while()
  } else if self.token.is_keyword(Keyword::For) {
      self.parse_stmt_for()
  } else if self.token.is_keyword(Keyword::Yeet) {
      self.parse_stmt_return()
  } else if self.token.kind == TokenKind::Semicolon {
      self.parse_stmt_empty()
  } else if self.token.is_keyword(Keyword::Fun) {
      self.parse_stmt_func_decl()
  } else if self.token.is_keyword(Keyword::Add) {
      self.parse_stmt_import()
  } else if self.token.is_keyword(Keyword::Br) {
      self.parse_stmt_break()
  } else if self.token.is_keyword(Keyword::Skip) {
      self.parse_stmt_continue()
  } else if self.token.can_begin_expr() {
      self.parse_stmt_expr()
  } else {
      let err = PError::ExpectedStatement {
          token: TokenType::Token(self.token.kind),
          span: self.token.span,
      };
      return Err(vec![err]);
  }
}
\end{lstlisting}

\subsubsection{Hàm \textit{parse\_stmt\_var\_decl}}
\label{ap1:stmt_decl_var}
\begin{lstlisting}
fn parse_stmt_var_decl(&mut self) -> PResult<Box<Stmt>> {
  if !self.token.is_keyword(Keyword::Set) {
      let err = PError::ExpectedToken {
          expected: vec![TokenType::Keyword(kw::to_symbol(Keyword::Set))],
          found: TokenType::Token(self.token.kind),
          span: self.token.span,
          prev_span: self.prev_token.span,
      };

      return Err(vec![err]);
  }

  let start = self.token.span;
  self.advance(); // 'set'

  let is_mut = if self.token.is_keyword(Keyword::Mut) {
      self.advance(); // 'mut'
      true
  } else {
      false
  };

  let ident = self.parse_ident()?;
  self.expect(TokenKind::Colon)?;
  self.advance(); // ':'
  let ty = self.parse_ty()?;

  let init = if self.token.kind == TokenKind::Eq {
      self.advance(); // expr
      Some(self.parse_expr()?)
  } else {
      None
  };

  self.expect(TokenKind::Semicolon)?;
  let span = start.to(self.token.span);

  self.advance();

  let kind = if let Some(init) = init {
      LocalKind::Init(init)
  } else {
      LocalKind::Decl
  };

  let local = Local {
      is_mut,
      ident,
      ty,
      kind,
      span,
  };
  let kind = StmtKind::Var(Box::new(local));
  let stmt = Box::new(Stmt { kind, span });

  Ok(stmt)
}
\end{lstlisting}

\subsubsection{Hàm \textit{parse\_stmt\_func\_decl}}
\label{ap1:stmt_decl_fun}
\begin{lstlisting}
fn parse_stmt_func_decl(&mut self) -> PResult<Box<Stmt>> {
  if !self.token.is_keyword(Keyword::Fun) {
      let err = PError::ExpectedToken {
          expected: vec![TokenType::Keyword(kw::to_symbol(Keyword::Fun))],
          found: TokenType::Token(self.token.kind),
          span: self.token.span,
          prev_span: self.prev_token.span,
      };
      return Err(vec![err]);
  }
  let start_span = self.token.span;
  self.advance(); // Eat "fn"

  let sig = self.parse_stmt_func_sig()?;
  let body = self.parse_stmt()?;

  let end_span = self.prev_token.span;
  let span = start_span.to(end_span);
  let kind = StmtKind::FuncDecl(Box::new(Fun { sig, body }));
  let stmt = Box::new(Stmt { kind, span });

  Ok(stmt)
}
\end{lstlisting}

\paragraph{Phân tích phần ký hiệu của hàm}.
\label{ap1:stmt_decl_fun_sig}
\begin{lstlisting}
fn parse_stmt_func_sig(&mut self) -> PResult<FunSig> {
  let start = self.token.span;
  let name = self.parse_ident()?;

  self.expect(TokenKind::OpenDelim(Delimiter::Parenthesis))?;
  self.advance();

  let mut inputs: Vec<FunParam> = Vec::new();
  loop {
      if self.token.is_close_delim(Delimiter::Parenthesis) {
          break;
      }

      let start = self.token.span;

      let is_mut = if self.token.is_keyword(Keyword::Mut) {
          self.advance(); // Eat 'mut'
          true
      } else {
          false
      };

      let ident = self.parse_ident()?;

      self.expect(TokenKind::Colon)?;
      self.advance(); // Eat ':'

      let ty = self.parse_ty()?;
      let end = self.prev_token.span;
      inputs.push(FunParam {
          ident,
          ty,
          is_mut,
          span: start.to(end),
      });

      if self.token.kind != TokenKind::Comma {
          break;
      }

      self.advance(); // Eat ','
  }

  self.expect(TokenKind::CloseDelim(Delimiter::Parenthesis))?;
  self.advance(); // Eat ')'

  let output = if self.token.kind == TokenKind::RArrow {
      self.advance(); // Eat '->'
      Some(self.parse_ty()?)
  } else {
      None
  };

  let end = self.prev_token.span;
  let span = start.to(end);

  Ok(FunSig {
      name,
      inputs,
      output,
      span,
  })
}
\end{lstlisting}

\subsubsection{Hàm \textit{parse\_stmt\_if}}
\label{ap1:stmt_when}
\begin{lstlisting}
fn parse_stmt_if(&mut self) -> PResult<Box<Stmt>> {
  if !self.token.is_keyword(Keyword::When) {
      let err = PError::ExpectedToken {
          expected: vec![TokenType::Keyword(kw::to_symbol(Keyword::When))],
          found: TokenType::Token(self.token.kind),
          span: self.token.span,
          prev_span: self.prev_token.span,
      };

      return Err(vec![err]);
  }

  let start_span = self.token.span;
  self.advance(); // Eat token after "if"
                  // Parse the condition expression.
  let condition = self.parse_expr()?;
  // Parse the block for the `if` statement.
  let if_block = self.parse_stmt()?;

  // Optionally parse an `else` block.
  let else_block = if self.token.is_keyword(Keyword::Alt) {
      self.advance(); // Eat token after `else`
      let else_block = self.parse_stmt()?;
      Some(else_block)
  } else {
      None
  };

  let end_span = self.prev_token.span;
  let span = start_span.to(end_span);
  let kind = StmtKind::If(condition, if_block, else_block);
  let stmt = Box::new(Stmt { kind, span });

  Ok(stmt)
}
\end{lstlisting}

\subsubsection{Hàm \textit{parse\_stmt\_while}}
\label{ap1:stmt_during}
\begin{lstlisting}
fn parse_stmt_while(&mut self) -> PResult<Box<Stmt>> {
  if !self.token.is_keyword(Keyword::During) {
      let err = PError::ExpectedToken {
          expected: vec![TokenType::Keyword(kw::to_symbol(Keyword::During))],
          found: TokenType::Token(self.token.kind),
          span: self.token.span,
          prev_span: self.prev_token.span,
      };

      return Err(vec![err]);
  }

  let start_span = self.token.span;
  self.advance();

  let condition = self.parse_expr()?;
  let block = self.parse_stmt()?;
  let end_span = self.prev_token.span;
  let span = start_span.to(end_span);
  let kind = StmtKind::While(condition, block);
  let stmt = Box::new(Stmt { kind, span });

  Ok(stmt)
}
\end{lstlisting}

\subsubsection{Hàm \textit{parse\_stmt\_for}}
\label{ap1:stmt_for}
\begin{lstlisting}
fn parse_stmt_for(&mut self) -> PResult<Box<Stmt>> {
  if !self.token.is_keyword(Keyword::For) {
      let err = PError::ExpectedToken {
          expected: vec![TokenType::Keyword(kw::to_symbol(Keyword::For))],
          found: TokenType::Token(self.token.kind),
          span: self.token.span,
          prev_span: self.prev_token.span,
      };

      return Err(vec![err]);
  }

  let start_span = self.token.span;

  self.advance();
  let ident = self.parse_ident()?;

  if !self.token.is_keyword(Keyword::In) {
      let err = PError::ExpectedToken {
          expected: vec![TokenType::Keyword(kw::to_symbol(Keyword::In))],
          found: TokenType::Token(self.token.kind),
          span: self.token.span,
          prev_span: self.prev_token.span,
      };

      return Err(vec![err]);
  }

  self.advance();
  let expr = self.parse_expr()?;
  let block = self.parse_stmt()?;
  let end_span = self.prev_token.span;
  let span = start_span.to(end_span);
  let kind = StmtKind::For(ident, expr, block);
  let stmt = Box::new(Stmt { kind, span });

  Ok(stmt)
}
\end{lstlisting}

\subsubsection{Hàm \textit{parse\_stmt\_return}}
\label{ap1:stmt_yeet}
\begin{lstlisting}
fn parse_stmt_return(&mut self) -> PResult<Box<Stmt>> {
  if !self.token.is_keyword(Keyword::Yeet) {
      let err = PError::ExpectedToken {
          expected: vec![TokenType::Keyword(kw::to_symbol(Keyword::Yeet))],
          found: TokenType::Token(self.token.kind),
          span: self.token.span,
          prev_span: self.prev_token.span,
      };

      return Err(vec![err]);
  }

  let start_span = self.token.span;
  self.advance();
  let kind = if self.token.can_begin_expr() {
      let expr = self.parse_expr()?;
      self.expect(TokenKind::Semicolon)?;
      self.advance();
      StmtKind::Return(Some(expr))
  } else {
      self.expect(TokenKind::Semicolon)?;
      self.advance();
      StmtKind::Return(None)
  };

  Ok(Box::new(Stmt {
      kind,
      span: start_span.to(self.prev_token.span),
  }))
}
\end{lstlisting}

\subsubsection{Hàm \textit{parse\_stmt\_empty}}
\label{ap1:stmt_semicolon}
\begin{lstlisting}
pub fn parse_stmt_empty(&mut self) -> PResult<Box<Stmt>> {
    self.expect(TokenKind::Semicolon)?;
    let span = self.token.span;
    self.advance();
    Ok(Box::new(Stmt {
        kind: StmtKind::Empty,
        span,
    }))
}
\end{lstlisting}

\subsubsection{Hàm \textit{parse\_stmt\_block}}
\label{ap1:stmt_block}
\begin{lstlisting}
pub fn parse_stmt_block(&mut self) -> PResult<Box<Stmt>> {
  self.expect(TokenKind::OpenDelim(Delimiter::Brace))?;
  let start = self.token.span;
  self.advance();

  let mut stmts = Vec::new();
  let mut errors: Vec<PError> = Vec::new();
  while self.token.kind != TokenKind::CloseDelim(Delimiter::Brace) {
      let result = self.parse_stmt();

      if let Err(mut err) = result {
          errors.append(&mut err);

          // recover may eat the closing brace, so we need to check again
          if self.token.kind != TokenKind::CloseDelim(Delimiter::Brace) {
              self.recover();
          }

          continue;
      }

      let stmt = result.unwrap();
      stmts.push(stmt);
  }

  let end = self.token.span;
  let span = start.to(end);
  let kind = StmtKind::Block(stmts);
  let stmt = Box::new(Stmt { kind, span });

  self.expect(TokenKind::CloseDelim(Delimiter::Brace))?;
  self.advance();

  if errors.is_empty() {
      Ok(stmt)
  } else {
      Err(errors)
  }
}
\end{lstlisting}

\subsubsection{Hàm \textit{parse\_stmt\_import}}
\label{ap1:stmt_add}
\begin{lstlisting}
fn parse_stmt_import(&mut self) -> PResult<Box<Stmt>> {
  if !self.token.is_keyword(Keyword::Add) {
      let err = PError::ExpectedToken {
          expected: vec![TokenType::Keyword(kw::to_symbol(Keyword::Add))],
          found: TokenType::Token(self.token.kind),
          span: self.token.span,
          prev_span: self.prev_token.span,
      };

      return Err(vec![err]);
  }

  let start_span = self.token.span;
  self.advance(); // Eat "import"

  let path = self.parse_ident()?;
  self.expect(TokenKind::Semicolon)?;
  let span = start_span.to(self.token.span);
  self.advance();

  let kind = StmtKind::Import(path);
  let stmt = Box::new(Stmt { kind, span });

  Ok(stmt)
}
\end{lstlisting}

\subsubsection{Hàm \textit{parse\_stmt\_break}}
\label{ap1:stmt_br}
\begin{lstlisting}
fn parse_stmt_break(&mut self) -> PResult<Box<Stmt>> {
  if !self.token.is_keyword(Keyword::Br) {
      let err = PError::ExpectedToken {
          expected: vec![TokenType::Keyword(kw::to_symbol(Keyword::Br))],
          found: TokenType::Token(self.token.kind),
          span: self.token.span,
          prev_span: self.prev_token.span,
      };

      return Err(vec![err]);
  }

  let span = self.token.span;
  self.advance(); // Eat token after "exit"

  self.expect(TokenKind::Semicolon)?;
  let span = span.to(self.token.span);
  self.advance();

  Ok(Box::new(Stmt {
      kind: StmtKind::Break,
      span,
  }))
}
\end{lstlisting}

\subsubsection{Hàm \textit{parse\_stmt\_continue}}
\label{ap1:stmt_skip}
\begin{lstlisting}
fn parse_stmt_continue(&mut self) -> PResult<Box<Stmt>> {
  if !self.token.is_keyword(Keyword::Skip) {
      let err = PError::ExpectedToken {
          expected: vec![TokenType::Keyword(kw::to_symbol(Keyword::Skip))],
          found: TokenType::Token(self.token.kind),
          span: self.token.span,
          prev_span: self.prev_token.span,
      };
      return Err(vec![err]);
  }
  let span = self.token.span;
  self.advance(); // Eat token after "skip"
  self.expect(TokenKind::Semicolon)?;
  let span = span.to(self.token.span);
  self.advance();
  Ok(Box::new(Stmt {
      kind: StmtKind::Continue,
      span,
  }))
}
\end{lstlisting}

\subsubsection{Hàm \textit{parse\_stmt\_expr}}
\label{ap1:stmt_expr}
\begin{lstlisting}
pub fn parse_stmt_expr(&mut self) -> PResult<Box<Stmt>> {
  let expr = self.parse_expr()?;
  let span = expr.span;
  let stmt = Box::new(Stmt {
      kind: StmtKind::Expr(expr),
      span,
  });

  self.expect(TokenKind::Semicolon)?;
  self.advance();

  Ok(stmt)
}
\end{lstlisting}

\subsubsection{Hàm \textit{parse\_expr}}
\label{ap1:expr}
\begin{lstlisting}
pub fn parse_expr(&mut self) -> PResult<Box<Expr>> {
  let lhs = self.parse_expr_prefix()?;
  self.parse_expr_rest(0, lhs)
}
\end{lstlisting}

\paragraph{Hàm \textit{parse\_expr\_prefix}}
\label{ap1:expr_prefix}
\begin{lstlisting}
fn parse_expr_prefix(&mut self) -> PResult<Box<Expr>> {
  match self.token.kind {
      TokenKind::Not => {
          let start = self.token.span;
          self.advance();
          let expr = self.parse_expr_prefix()?;
          let span = start.to(expr.span);
          let expr = self.mk_unary(UnOp::Not, expr);
          Ok(self.mk_expr(expr, span))
      }
      TokenKind::BinOp(BinOpToken::Minus) => {
          let start = self.token.span;
          self.advance();
          let expr = self.parse_expr_prefix()?;
          let span = start.to(expr.span);
          let expr = self.mk_unary(UnOp::Ne, expr);
          Ok(self.mk_expr(expr, span))
      }
      _ => self.parse_expr_dot_or_call(),
  }
}
\end{lstlisting}

\paragraph{Hàm \textit{parse\_expr\_dot\_or\_call}}
\label{ap1:expr_dot_or_call}
\begin{lstlisting}

\end{lstlisting}

\paragraph{Hàm \textit{parse\_expr\_bottom}}
\label{ap1:expr_bottom}
\begin{lstlisting}

\end{lstlisting}

\paragraph{Hàm \textit{parse\_expr\_dot\_or\_call\_with}}
\label{ap1:expr_dot_or_call_with}
\begin{lstlisting}

\end{lstlisting}

\paragraph{Hàm \textit{parse\_expr\_rest}}
\label{ap1:expr_rest}
\begin{lstlisting}

\end{lstlisting}


}

\paragraph{Hàm \textit{}}
\label{ap1:}
\begin{lstlisting}

\end{lstlisting}

\begin{lstlisting}

\end{lstlisting}